
-import os
-import streamlit as st
-from pathlib import Path
 import json
+import os
 from datetime import datetime
+from pathlib import Path
 
+import streamlit as st
+
+from chatbot import Chatbot, QuizGenerator
 from document_processor import DocumentProcessor
 from vector_store import VectorStore
-from chatbot import Chatbot, QuizGenerator
 
 # Configuration de la page
 st.set_page_config(
     page_title="EduLLM - Assistant d'Apprentissage IA",
     page_icon="üéì",
     layout="wide",
-    initial_sidebar_state="expanded"
+    initial_sidebar_state="expanded",
 )
 
 # Styles CSS personnalis√©s
-st.markdown("""
+st.markdown(
+    """
     <style>
     .main {
         max-width: 1200px;
         padding: 2rem;
     }
     .chat-message {
         padding: 1rem;
         border-radius: 0.5rem;
         margin-bottom: 1rem;
         max-width: 80%;
     }
     .user-message {
         background-color: #e3f2fd;
         margin-left: auto;
         margin-right: 0;
     }
     .assistant-message {
         background-color: #f5f5f5;
         margin-right: auto;
         margin-left: 0;
     }
     .sidebar .sidebar-content {
         background-color: #f8f9fa;
     }
     .stButton>button {
         width: 100%;
     }
     .file-uploader {
         border: 2px dashed #ccc;
         border-radius: 0.5rem;
         padding: 2rem;
         text-align: center;
         margin: 1rem 0;
     }
     </style>
-""", unsafe_allow_html=True)
+""",
+    unsafe_allow_html=True,
+)
 
 # Initialisation de la session
-if 'vector_store' not in st.session_state:
+if "vector_store" not in st.session_state:
     st.session_state.vector_store = VectorStore()
     st.session_state.chatbot = Chatbot(st.session_state.vector_store)
     st.session_state.quiz_generator = QuizGenerator(st.session_state.vector_store)
     st.session_state.messages = []
     st.session_state.uploaded_files = []
     st.session_state.current_doc_id = None
     st.session_state.quiz_data = None
 
+
 def display_chat_message(role, content):
     """Affiche un message dans la conversation."""
     with st.chat_message(role):
         st.markdown(content)
 
+
 def display_chat_history():
     """Affiche l'historique de la conversation."""
     for message in st.session_state.messages:
         role = "user" if message["role"] == "user" else "assistant"
         display_chat_message(role, message["content"])
 
+
 def process_uploaded_files(uploaded_files):
     """Traite les fichiers t√©l√©charg√©s par l'utilisateur."""
     if not uploaded_files:
         return []
-    
+
     uploaded_file_paths = []
-    
+
     for uploaded_file in uploaded_files:
         # Cr√©er le r√©pertoire de t√©l√©chargement s'il n'existe pas
         upload_dir = Path("data/uploads")
         upload_dir.mkdir(parents=True, exist_ok=True)
-        
+
         # Sauvegarder le fichier
         file_path = upload_dir / uploaded_file.name
         with open(file_path, "wb") as f:
             f.write(uploaded_file.getbuffer())
-        
+
         # Ajouter le document au vector store
         try:
             doc_id = st.session_state.vector_store.add_document(str(file_path))
             st.session_state.current_doc_id = doc_id
-            uploaded_file_paths.append({
-                'name': uploaded_file.name,
-                'path': str(file_path),
-                'id': doc_id,
-                'size': f"{uploaded_file.size / 1024:.1f} KB"
-            })
+            uploaded_file_paths.append(
+                {
+                    "name": uploaded_file.name,
+                    "path": str(file_path),
+                    "id": doc_id,
+                    "size": f"{uploaded_file.size / 1024:.1f} KB",
+                }
+            )
             st.success(f"Document trait√© avec succ√®s: {uploaded_file.name}")
         except Exception as e:
-            st.error(f"Erreur lors du traitement du fichier {uploaded_file.name}: {str(e)}")
-    
+            st.error(
+                f"Erreur lors du traitement du fichier {uploaded_file.name}: {str(e)}"
+            )
+
     # Mettre √† jour la liste des fichiers t√©l√©charg√©s
     st.session_state.uploaded_files = uploaded_file_paths
     return uploaded_file_paths
 
+
 def generate_quiz():
     """G√©n√®re un quiz bas√© sur le document actuel ou un th√®me."""
     # V√©rifier si un document est s√©lectionn√© ou si un th√®me est fourni
-    doc_id = st.session_state.get('current_doc_id')
-    topic = st.session_state.get('quiz_topic', '')
-    
+    doc_id = st.session_state.get("current_doc_id")
+    topic = st.session_state.get("quiz_topic", "")
+
     if not doc_id and not topic.strip():
-        st.warning("Veuillez d'abord t√©l√©charger un document ou sp√©cifier un th√®me pour le quiz.")
+        st.warning(
+            "Veuillez d'abord t√©l√©charger un document ou sp√©cifier un th√®me pour le quiz."
+        )
         return
-    
+
     with st.spinner("G√©n√©ration du quiz en cours..."):
         try:
             # R√©cup√©rer les param√®tres du quiz depuis l'interface
-            num_questions = st.session_state.get('num_questions', 5)
-            difficulty = st.session_state.get('quiz_difficulty', 'moyen')
-            
+            num_questions = st.session_state.get("num_questions", 5)
+            difficulty = st.session_state.get("quiz_difficulty", "moyen")
+
             # G√©n√©rer le quiz
             quiz_data = st.session_state.quiz_generator.generate_quiz(
                 topic=topic if topic.strip() else None,
                 doc_id=doc_id,
                 num_questions=num_questions,
-                difficulty=difficulty
+                difficulty=difficulty,
             )
-            
+
             # V√©rifier s'il y a une erreur dans la r√©ponse
-            if isinstance(quiz_data, dict) and 'error' in quiz_data:
-                error_msg = quiz_data.get('error', 'Erreur inconnue')
-                details = quiz_data.get('details', '')
+            if isinstance(quiz_data, dict) and "error" in quiz_data:
+                error_msg = quiz_data.get("error", "Erreur inconnue")
+                details = quiz_data.get("details", "")
                 st.error(f"Erreur lors de la g√©n√©ration du quiz: {error_msg}")
                 if details:
                     st.warning(f"D√©tails: {details}")
                 return
-            
+
             # V√©rifier la structure des donn√©es du quiz
-            if not isinstance(quiz_data, dict) or 'questions' not in quiz_data:
+            if not isinstance(quiz_data, dict) or "questions" not in quiz_data:
                 st.error("Format de quiz invalide re√ßu du g√©n√©rateur.")
                 return
-            
+
             # Sauvegarder les donn√©es du quiz dans la session
             st.session_state.quiz_data = quiz_data
             st.session_state.show_quiz = True
-            
+
             # Afficher un message de succ√®s
             st.success("Quiz g√©n√©r√© avec succ√®s !")
-            
+
         except Exception as e:
             st.error(f"Une erreur inattendue est survenue : {str(e)}")
-            st.warning("Veuillez r√©essayer ou contacter le support si le probl√®me persiste.")
+            st.warning(
+                "Veuillez r√©essayer ou contacter le support si le probl√®me persiste."
+            )
+
 
 def display_quiz():
     """Affiche le quiz g√©n√©r√©."""
-    if not st.session_state.get('quiz_data'):
+    if not st.session_state.get("quiz_data"):
         return
-    
+
     quiz = st.session_state.quiz_data
-    
+
     st.markdown(f"## {quiz.get('title', 'Quiz')}")
     st.markdown(f"*{quiz.get('description', '')}*")
     st.markdown(f"**Difficult√© :** {quiz.get('difficulty', 'Moyen').capitalize()}")
-    
-    if 'questions' in quiz and quiz['questions']:
+
+    if "questions" in quiz and quiz["questions"]:
         st.markdown("### Questions")
-        
+
         user_answers = {}
-        for i, question in enumerate(quiz['questions'], 1):
+        for i, question in enumerate(quiz["questions"], 1):
             st.markdown(f"**{i}. {question['question']}**")
-            
+
             # Afficher les options de r√©ponse
-            options = question.get('options', {})
+            options = question.get("options", {})
             selected = st.radio(
                 f"Options pour la question {i}",
                 options=[f"{k}. {v}" for k, v in options.items()],
                 key=f"q_{i}",
-                index=None
+                index=None,
             )
-            
+
             if selected:
                 user_answers[i] = selected[0]  # Stocker la lettre de la r√©ponse
-                
+
                 # Afficher la correction si l'utilisateur a r√©pondu
-                if user_answers[i] == question['correct_answer']:
+                if user_answers[i] == question["correct_answer"]:
                     st.success("Correct !")
                 else:
-                    st.error(f"Incorrect. La bonne r√©ponse est {question['correct_answer'].upper()}.")
-                
-                st.markdown(f"*Explication*: {question.get('explanation', 'Aucune explication disponible.')}")
-            
+                    st.error(
+                        f"Incorrect. La bonne r√©ponse est {question['correct_answer'].upper()}."
+                    )
+
+                st.markdown(
+                    f"*Explication*: {question.get('explanation', 'Aucune explication disponible.')}"
+                )
+
             st.markdown("---")
-        
+
         # Afficher le score si toutes les questions ont √©t√© r√©pondues
-        if len(user_answers) == len(quiz['questions']):
-            correct = sum(1 for i, q in enumerate(quiz['questions'], 1) 
-                        if user_answers.get(i, '').startswith(q['correct_answer']))
-            score = (correct / len(quiz['questions'])) * 100
-            
+        if len(user_answers) == len(quiz["questions"]):
+            correct = sum(
+                1
+                for i, q in enumerate(quiz["questions"], 1)
+                if user_answers.get(i, "").startswith(q["correct_answer"])
+            )
+            score = (correct / len(quiz["questions"])) * 100
+
             st.markdown(f"### R√©sultat du quiz: {score:.1f}%")
             st.progress(score / 100)
-            
+
             if score >= 70:
                 st.balloons()
                 st.success("F√©licitations ! Vous avez r√©ussi le quiz ! üéâ")
             else:
-                st.warning("Vous pouvez faire mieux ! N'h√©sitez pas √† revoir le document et √† r√©essayer.")
+                st.warning(
+                    "Vous pouvez faire mieux ! N'h√©sitez pas √† revoir le document et √† r√©essayer."
+                )
     else:
         st.warning("Aucune question n'a √©t√© g√©n√©r√©e pour ce quiz.")
 
+
 def main():
     """Fonction principale de l'application."""
     # Barre lat√©rale
     with st.sidebar:
         st.title("üìö EduLLM")
         st.markdown("*Votre assistant d'apprentissage intelligent*")
-        
+
         st.markdown("---")
-        
+
         # T√©l√©chargement de documents
         st.subheader("Documents")
         uploaded_files = st.file_uploader(
             "T√©l√©chargez vos documents (PDF, TXT, DOCX, PPTX)",
             type=["pdf", "txt", "docx", "pptx"],
             accept_multiple_files=True,
-            key="file_uploader"
+            key="file_uploader",
         )
-        
+
         if st.button("Traiter les documents"):
             if uploaded_files:
                 with st.spinner("Traitement des documents..."):
                     process_uploaded_files(uploaded_files)
-        
+
         # Liste des documents t√©l√©charg√©s
         if st.session_state.uploaded_files:
             st.markdown("### Documents trait√©s")
             for file in st.session_state.uploaded_files:
                 with st.expander(f"üìÑ {file['name']}"):
                     st.caption(f"Taille: {file['size']}")
                     if st.button("S√©lectionner", key=f"select_{file['id']}"):
-                        st.session_state.current_doc_id = file['id']
+                        st.session_state.current_doc_id = file["id"]
                         st.experimental_rerun()
-        
+
         st.markdown("---")
-        
+
         # Options
         st.subheader("Options")
         if st.button("Nouvelle conversation"):
             st.session_state.messages = []
             st.session_state.chatbot.clear_history()
             st.experimental_rerun()
-        
+
         # Section de g√©n√©ration de quiz
         st.markdown("---")
         st.subheader("G√©n√©rer un quiz")
-        
+
         # Champ pour le th√®me du quiz
         quiz_topic = st.text_input(
             "Th√®me du quiz (optionnel si un document est s√©lectionn√©)",
             key="quiz_topic",
-            help="Laissez vide pour g√©n√©rer un quiz bas√© sur le document s√©lectionn√©"
+            help="Laissez vide pour g√©n√©rer un quiz bas√© sur le document s√©lectionn√©",
         )
-        
+
         # S√©lecteur du nombre de questions
         num_questions = st.slider(
             "Nombre de questions",
             min_value=3,
             max_value=10,
             value=5,
             step=1,
-            key="num_questions"
+            key="num_questions",
         )
-        
+
         # S√©lecteur de difficult√©
         difficulty = st.selectbox(
             "Niveau de difficult√©",
             ["Facile", "Moyen", "Difficile"],
             index=1,  # Moyen par d√©faut
-            key="quiz_difficulty"
+            key="quiz_difficulty",
         )
-        
+
         # Bouton de g√©n√©ration
         if st.button("G√©n√©rer le quiz", key="generate_quiz_btn"):
             # V√©rifier qu'au moins un document est s√©lectionn√© ou qu'un th√®me est fourni
-            if not st.session_state.get('current_doc_id') and not quiz_topic.strip():
-                st.warning("Veuillez s√©lectionner un document ou saisir un th√®me pour le quiz.")
+            if not st.session_state.get("current_doc_id") and not quiz_topic.strip():
+                st.warning(
+                    "Veuillez s√©lectionner un document ou saisir un th√®me pour le quiz."
+                )
             else:
                 generate_quiz()
-        
+
         # Afficher l'√©tat actuel
-        if st.session_state.get('current_doc_id'):
-            current_doc = next((doc for doc in st.session_state.uploaded_files 
-                             if doc['id'] == st.session_state.current_doc_id), None)
+        if st.session_state.get("current_doc_id"):
+            current_doc = next(
+                (
+                    doc
+                    for doc in st.session_state.uploaded_files
+                    if doc["id"] == st.session_state.current_doc_id
+                ),
+                None,
+            )
             if current_doc:
                 st.info(f"Document s√©lectionn√©: {current_doc['name']}")
-        
+
         if quiz_topic.strip():
             st.info(f"Th√®me du quiz: {quiz_topic}")
-            
+
         st.markdown("---")
-        
+
         st.markdown("---")
-        
+
         # Aide et informations
         st.markdown("### Aide")
-        st.markdown("""
+        st.markdown(
+            """
         - T√©l√©chargez vos documents de cours
         - Posez des questions sur le contenu
         - G√©n√©rez des quiz pour vous tester
-        """)
-    
+        """
+        )
+
     # Contenu principal
     st.title("üí¨ EduLLM - Assistant d'Apprentissage")
-    
+
     # Afficher le quiz s'il est disponible
-    if st.session_state.get('show_quiz', False):
+    if st.session_state.get("show_quiz", False):
         if st.button("Retour au chat"):
             st.session_state.show_quiz = False
             st.experimental_rerun()
         display_quiz()
         return
-    
+
     # Afficher l'historique de la conversation
     display_chat_history()
-    
+
     # Zone de saisie pour les messages
     if prompt := st.chat_input("Posez votre question ici..."):
         # Ajouter le message de l'utilisateur
         display_chat_message("user", prompt)
         st.session_state.messages.append({"role": "user", "content": prompt})
-        
+
         # Obtenir et afficher la r√©ponse de l'assistant
         with st.chat_message("assistant"):
             with st.spinner("R√©flexion en cours..."):
                 try:
                     response = st.session_state.chatbot.process_query(prompt)
-                    st.markdown(response['response'])
-                    
+                    st.markdown(response["response"])
+
                     # Afficher les sources si disponibles
-                    if response.get('sources'):
+                    if response.get("sources"):
                         st.markdown("\n**Sources :**")
-                        for source in response['sources']:
+                        for source in response["sources"]:
                             st.markdown(f"- {source}")
-                    
+
                     # Ajouter la r√©ponse √† l'historique
-                    st.session_state.messages.append({
-                        "role": "assistant", 
-                        "content": response['response'],
-                        "sources": response.get('sources', [])
-                    })
+                    st.session_state.messages.append(
+                        {
+                            "role": "assistant",
+                            "content": response["response"],
+                            "sources": response.get("sources", []),
+                        }
+                    )
                 except Exception as e:
                     error_msg = f"D√©sol√©, une erreur s'est produite : {str(e)}"
                     st.error(error_msg)
-                    st.session_state.messages.append({
-                        "role": "assistant", 
-                        "content": error_msg,
-                        "error": True
-                    })
+                    st.session_state.messages.append(
+                        {"role": "assistant", "content": error_msg, "error": True}
+                    )
+
 
 if __name__ == "__main__":
     main()
